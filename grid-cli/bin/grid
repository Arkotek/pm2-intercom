#!/usr/bin/env node

const program      = require('commander');
const fs           = require('fs');
const path         = require('path');
const package      = require('../package.json');
const sshexec      = require('ssh-exec');
const chalk        = require('chalk');
const cliSpinners  = require('cli-spinners');
const async        = require('async');
const grid         = require('grid-api');
const cliux        = require('../lib/cli-ux.js');
const multissh     = require('multissh');
const shelljs      = require('shelljs');
const Common       = require('../lib/common.js');
const SSH          = require('../workflows/ssh.js');
const publicIp     = require('public-ip');

program
  .version(package.version);

program
  .command('list')
  .alias('ls')
  .option('--watch')
  .option('--raw')
  .description('List all peers connected to network')
  .action(function(opts) {
    if (opts.watch === true)
      cliux.displayHostsWatch();
    else if (opts.raw === true) {
      grid.listHosts(function(err, hosts) {
        if (err) return exitError(err);
        console.log(JSON.stringify(hosts, '', 2));
      });
    }
    else
      Common.displayHosts();
  });

program
  .command('dump <filename>')
  .description('Save all hosts connected to a hostfile')
  .action(function(filename) {

    filename = filename + '.hostfile';

    listServerForMulti(function(err, node_list) {
      if (err) return exitError(err);
      try {
        fs.unlinkSync(filename);
      } catch(e) {}
      node_list.forEach(function(node) {
        fs.appendFileSync(filename, node.user + ':' + node.ip + '\n');
      });
      console.log(chalk.bold.blue(filename + ' hostfile content:'));
      shelljs.exec('cat ' + filename);
      console.log('');
      console.log(chalk.bold.blue('To generate new SSH keypair:'))
      console.log(chalk.bold('$ grid keygen <key_name>'));
      console.log(chalk.bold.blue('To copy public SSH key:'))
      console.log(chalk.bold('$ grid keycopy ' + filename + '<key_name>'));
      console.log(chalk.bold.blue('To recover the grid:'))
      console.log(chalk.bold('$ grid recover ' + filename));
      exitSuccess();
    });
  });

/**
 * These following commands uses directly SSH
 */

program
  .command('keygen <filename>')
  .option('--no-chmod')
  .description('Generate SSH keypairs')
  .action(function(name, opts) {
    console.log(chalk.bold('Generating, it can take some time (~10secs)'));

    SSH.generate_keypair(name)
      .then((keypair) => {
        console.log(chalk.bold('Done.\n'));

        var public_key = name + '.pub';

        fs.writeFileSync(public_key, keypair.public);
        fs.writeFileSync(name, keypair.private);

        if (opts.chmod) {
          fs.chmodSync(public_key, '400');
          fs.chmodSync(name, '400');
        }

        console.log('Public key:');
        console.log(chalk.grey('./' + public_key));
        console.log('Private key:');
        console.log(chalk.grey('./' + name));
        console.log('Copy to target hosts:');
        console.log(chalk.grey('$ grid keycopy <hostfile> ' + public_key));
        exitSuccess();
      })
      .catch(e => {
        exitError(e);
      });

  });

program
  .command('keycopy <hostfile> [custom_ssh_key]')
  .option('--only <ip>')
  .alias('setup-key')
  .description('Install public key on remote hosts (default to $HOME/.ssh/id_rsa.pub)')
  .action(function(hostfile, custom_key, opts) {
    SSH.copy_public_key(hostfile, custom_key, opts)
      .then(commands => {
        console.log('Keys copied to %d hosts', commands.length);
        exitSuccess();
      })
      .catch(e => {
        exitError(e);
      })
  });

program
  .command('recover <hostfile> <gridname>')
  .option('--key <public_key>')
  .description('Force all nodes (via SSH) to recover')
  .action(function(hostfile, gridname, opts) {
    var hosts = fs.readFileSync(hostfile).toString().trim().split('\n');

    SSH.recover(hosts, gridname, opts)
      .then(() => {
        setTimeout(function() {
          Common.displayHosts(function() {
            exitSuccess('✓ Remote node successfully provisioned');
          });
        }, 1500);
      })
      .catch(e => {
        exitError(e);
      });
  });

program
  .command('import <hostfile> <gridname> [public_key]')
  .description('Force all nodes (via SSH) to recover')
  .action(function(hostfile, gridname, public_key) {

    var p_hosts = fs.readFileSync(hostfile).toString().trim().split('\n');
    var server_list = [];

    p_hosts.forEach(function(host) {
      var dt = {
        user : host.split(':')[0],
        ip   : host.split(':')[1]
      }
      if (public_key)
        dt.key = path.join(process.cwd(), public_key)
      server_list.push(dt);
    });

    execCmd({
      cmd : 'GRID=' + gridname + ' pm2 restart gridcontrol',
      server_list : server_list,
      title : 'Moving Nodes to new grid name'
    });
  });


program
  .command('provision <username> <ip> <grid_name>')
  .option('--key <public_ssh_key>')
  .description('provision a remote node')
  .action(function(username, ip, namespace, opts) {
    SSH.provision_target(username, ip, namespace, opts)
      .then(function() {
        Common.displayHosts(function() {
          exitSuccess('✓ Remote node successfully provisioned');
        });
      })
      .catch(e => {
        exitError(e);
      })
  });

/**
 * These commands uses hosts currently linked together (and not SSH)
 */
program
  .command('reset')
  .alias('clear')
  .description('Clear all')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);

      execCmd({
        cmd : 'pm2 delete all ; pm2 restart gridcontrol',
        server_list : server_list,
        title : 'Clearing all tasks and restarting GC'
      });

    });
  });

program
  .command('unprovision')
  .description('Uninstall grid control on all nodes')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);

      execCmd({
        cmd : 'pm2 uninstall gridcontrol',
        server_list : server_list,
        title : 'Unprovisioning Gridcontrol'
      });

    });
  });

program
  .command('init [grid_name]')
  .alias('install')
  .description('Install a local Gridcontrol Node')
  .action(function(grid_name) {
    require('../workflows/init.js')(grid_name);
  });

program
  .command('move <new_grid_name>')
  .description('move all server to another grid namespace')
  .action(function(new_grid_name) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);

      execCmd({
        cmd         : 'GRID="' + new_grid_name + '" pm2 restart gridcontrol',
        server_list : server_list,
        title       : 'Moving current grid to new one'
      });
    });
  });

program
  .command('list-tasks')
  .alias('tasks')
  .description('List all tasks')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);

      execCmd({
        cmd         : 'pm2 ls',
        server_list : server_list,
        title       : 'List all tasks'
      });
    });
  });

program
  .command('upgrade [version]')
  .description('Upgrade whole grid to latest gridcontrol version')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      grid.listHosts(function(err, hosts) {

        execCmd({
          cmd         : 'GRID=' + hosts[0].ns + ' pm2 install gridcontrol',
          server_list : server_list,
          title       : 'Upgrading Gridcontrol to latest'
        });

      })
    });
  });

program
  .command('spread <bash_command>')
  .description('Execute a bash command on each Grid nodes')
  .action(function(bash_command) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);

      execCmd({
        cmd         : bash_command,
        server_list : server_list
      });
    });
  });

program
  .command('logs [task_name]')
  .alias('log')
  .description('Display logs of all nodes')
  .action(function(task_name) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      var cmd = 'pm2 logs' + (task_name ? ' ' + task_name : '');

      execCmd({
        cmd         : cmd,
        server_list : server_list,
        title       : 'Displaying logs'
      });

    });
  });

program
  .command('monitor <secret_key> <public_key>')
  .description('Monitor all nodes and tasks with Keymetrics (https://keymetrics.io)')
  .action(function(secret, public) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      var cmd = 'pm2 link ' + secret + ' ' + public;

      execCmd({
        cmd         : cmd,
        server_list : server_list,
        title       : 'Monitoring Nodes with Keymetrics'
      });
    });
  });

program
  .command('restart')
  .description('Restart local Gridcontrol app')
  .action(function() {
    var shelljs = require('shelljs');

    shelljs.exec('pm2 restart gridcontrol', { silent : true }, function(code, stderr, stdout) {

      if (code != 0) {
        return exitError(new Error('Gridcontrol is not launched'));
      }

      Common.displayHosts(function() {
        exitSuccess()
      });
    });
  });

program
  .command('status')
  .description('Status data about the current grid')
  .action(function() {
  });

program
  .command('invoke')
  .description('List all peers connected to network')
  .action(function() {
  });

/**
 * Generics
 */
program
  .command('*')
  .action(function(env){
    console.log('Enter a Valid command');
    program.outputHelp();
    process.exit(0);
  });

program.parse(process.argv);

if (!process.argv.slice(2).length) {
  program.outputHelp();
}

/**
 * @param {Object}   opts
 * @param {String}   opts.cmd command to execute
 * @param {Object[]} opts.server_list Server list (ip, user, local)
 * @param {String}   [opts.title="MultiSSH] Optional window title
 */
function execCmd(opts) {
  multissh.start(opts, function() {
    Common.displayHosts(function() {
      exitSuccess()
    });
  });
};

function listServerForMulti(cb) {
  grid.listHosts(function(err, hosts) {
    if (err) return cb(err);
    var server_list = [];

    hosts.forEach(function(host) {
      server_list.push({
        ip : host.public_ip,
        user : host.user,
        local : host.local
      });
    });

    return cb(null, server_list);
  });
}

function exitError(err) {
  console.error(err);
  process.exit(1);
}

function exitSuccess(msg) {
  console.log('');
  console.log(chalk.bold.green(msg || '✓ Action successfully executed'));
  process.exit(0);
}
