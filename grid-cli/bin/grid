#!/usr/bin/env node

const program      = require('commander');
const fs           = require('fs');
const path         = require('path');
const package      = require('../package.json');
const sshexec      = require('ssh-exec');
const chalk        = require('chalk');
const cliSpinners  = require('cli-spinners');
const async        = require('async');
const grid         = require('grid-api');
const cliux        = require('./cli-ux.js');
const multissh     = require('multissh');
const ora          = require('ora');
const shelljs      = require('shelljs');

program
  .version(package.version);

/**
 * Customs
 */
program
  .option('--watch')
  .command('list')
  .alias('ls')
  .description('List all peers connected to network')
  .action(function() {
    if (program.watch === true)
      cliux.displayHostsWatch();
    else
      displayHosts();
  });

program
  .command('status')
  .description('Status data about the current grid')
  .action(function() {
  });

program
  .command('invoke')
  .description('List all peers connected to network')
  .action(function() {
  });

program
  .command('recover')
  .description('SSH to all machines')
  .action(function() {
  });

program
  .command('reset')
  .alias('clear')
  .description('Clear all')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      execCmd('pm2 delete all ; pm2 restart gridcontrol', server_list);
    });
  });

program
  .command('unprovision')
  .description('Uninstall grid control on all nodes')
  .action(function() {
  });

program
  .command('init [grid_name]')
  .alias('install')
  .description('Install a local Gridcontrol Node')
  .action(function(grid_name) {

    const inquirer     = require('inquirer');
    // Display banner
    var a = fs.readFileSync(__dirname + '/../pres/ascii2')
    console.log(a.toString());

    new Promise((resolve, reject) => {
      // Determine grid name
      if (grid_name)
        return resolve(grid_name);
      return inquirer.prompt([{
        message :'Grid name?',
        type : 'input',
        name : 'grid_name'
      }]).then(answers => {
        return resolve(answers.grid_name);
      });
    }).then(function(grid_name) {
      // Install PM2
      console.log(chalk.bold('Initializing Grid: ' + grid_name));

      return new Promise((resolve, reject) => {
        var spinner = ora({
          text : chalk.bold('Installing Process Manager PM2'),
          spinner: 'arrow3'
        });

        spinner.start();

        if (shelljs.which('pm2')) {
          spinner.stop();
          return resolve(grid_name);
        }
        var cmd = 'npm install pm2 -g';

        shelljs.exec(cmd, { silent : true}, (code, stdout, stderr) => {
          spinner.stop();
          if (code != 0) return reject(stderr);
          return resolve(grid_name);
        });
      });

    }).then(function(grid_name) {
      // Install Gridcontrol
      return new Promise((resolve, reject) => {
        var spinner = ora({
          text : chalk.bold('Installing Network layer'),
          spinner: 'arrow3'
        });

        spinner.start();
        var cmd = 'GRID=' + grid_name + ' pm2 install gridcontrol';

        shelljs.exec(cmd, {silent:true}, (code, stdout, stderr) => {
          spinner.stop();
          if (code != 0) return reject(stderr);
          return resolve();
        })
      });
    }).then(function() {
      displayHosts();
    }).catch(function(e) {
      console.error(chalk.bold.red('Error while initializing:'));
      console.error(e);
    });
  });

program
  .command('move <new_grid_name>')
  .description('move all server to another grid namespace')
  .action(function(new_grid_name) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      return execCmd('GRID="' + new_grid_name + '" pm2 restart gridcontrol', server_list);
    });
  });

program
  .command('provision <username> <ip> <grid_name>')
  .description('provision a remote node')
  .action(function(username, ip, namespace) {
    var exec = require('child_process').exec;
    var strssh = username + '@' + ip;

    var child = exec('scp ' + __dirname + '/../install.sh ' + strssh + ':/tmp');

    child.stdout.on('data', function(data) {
      console.log('stdout: ' + data);
    });

    child.stderr.on('data', function(data) {
      console.log('stderr: ' + data);
    });

    child.on('close', function(code) {
      console.log('Install script copied with code %d', code);

      var stream = sshexec("PS1='$ ' source ~/.bashrc; cat /tmp/install.sh | GRID=" + namespace + " bash", strssh);

      stream.on('data', function(dt) {
        process.stdout.write(dt.toString());
      });

      stream.on('error', function(e) {
        console.log('Got error', e.message || e);
      });

      stream.on('exit', function() {
        exitSuccess();
      });

    });
  });

program
  .command('list-tasks')
  .alias('tasks')
  .description('List all tasks')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      execCmd('pm2 ls', server_list);
    });
  });

program
  .command('upgrade [version]')
  .description('Upgrade whole grid to latest gridcontrol version')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      execCmd('pm2 install gridcontrol', server_list);
    });
  });

program
  .command('spread <bash_command>')
  .description('Execute a bash command on each Grid nodes')
  .action(function(bash_command) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      execCmd(bash_command, server_list);
    });
  });

program
  .command('logs [task_name]')
  .description('Display logs of all nodes')
  .action(function(task_name) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      var cmd = 'pm2 logs' + (task_name ? ' ' + task_name : '');
      execCmd(cmd, server_list);
    });
  });

program
  .command('monitor <secret_key> <public_key>')
  .description('Monitor all nodes and tasks with Keymetrics (https://keymetrics.io)')
  .action(function(secret, public) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      var cmd = 'pm2 link ' + secret + ' ' + public;
      execCmd(cmd, server_list);
    });
  });

program
  .command('restart')
  .description('Restart local Gridcontrol app')
  .action(function() {
    var shelljs = require('shelljs');

    shelljs.exec('pm2 restart gridcontrol', function() {
      exitSuccess();
    });
  });

function execCmd(cmd, server_list) {
  multissh.start(cmd, server_list, function() {
    displayHosts();
    setTimeout(function() {
      process.exit(0);
    }, 40);
  });
};

function displayHosts(cb) {
  var retry_count = 0;

  function disp(cb) {
    grid.listHosts(function(err, hosts) {
      if (err && cb) return cb(new Error('cannot connect'));
      if (err) exitError(err);
      return cliux.displayHosts(hosts);
    });
  }

  function retry() {
    setTimeout(function() {
      retry_count++;

      if (retry_count > 20) {
        return exitError(new Error('Cannot connect to local gridcontrol'));
      }
      disp(function(err) {
        if (!err)
          return setTimeout(function() { exitSuccess() }, 150);
        return retry();
      });
    }, 200);
  }

  disp(function(err) {
    if (err) return retry();
    return setTimeout(function() { exitSuccess() }, 150);
  });
};

function listServerForMulti(cb) {
  grid.listHosts(function(err, hosts) {
    if (err) return cb(err);
    var server_list = [];

    hosts.forEach(function(host) {
      server_list.push({
        ip : host.public_ip,
        user : host.user,
        local : host.local
      });
    });

    return cb(null, server_list);
  });
}

/**
 * Generics
 */
program
  .command('*')
  .action(function(env){
    console.log('Enter a Valid command');
    program.outputHelp();
    process.exit(0);
  });

program.parse(process.argv);

if (!process.argv.slice(2).length) {
  program.outputHelp();
}

function exitError(err) {
  console.error(err);
  process.exit(1);
}

function exitSuccess(msg) {
  console.log(chalk.bold.green(msg || 'Action successfully executed'));
  process.exit(0);
}
