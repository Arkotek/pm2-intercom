#!/usr/bin/env node

const program      = require('commander');
const fs           = require('fs');
const path         = require('path');
const package      = require('../package.json');
const sshexec      = require('ssh-exec');
const chalk        = require('chalk');
const cliSpinners  = require('cli-spinners');
const async        = require('async');
const grid         = require('grid-api');
const cliux        = require('../lib/cli-ux.js');
const multissh     = require('multissh');
const shelljs      = require('shelljs');
const Common       = require('../lib/common.js');
const INIT         = require('../lib/workflows/init.js')
const SSH          = require('../lib/workflows/ssh.js');
const publicIp     = require('public-ip');

program
  .version(package.version);

// program
//   .command('install [grid_name]')
//   .description('Generate Gridfile + Install a local Gridcontrol Node')
//   .action(function(grid_name) {
//     Common.generateGridfile(process.cwd())
//       .then((data) => {
//         console.log(chalk.bold('Grifile generated in path %s'), data.file);
//         return INIT(grid_name);
//       });
//   });

program
  .command('list')
  .alias('ls')
  .option('--watch')
  .option('--raw')
  .description('List all peers connected to network')
  .action(function(opts) {
    if (opts.watch === true)
      cliux.displayHostsWatch();
    else if (opts.raw === true) {
      grid.listHosts(function(err, hosts) {
        if (err) return exitError(err);
        console.log(JSON.stringify(hosts, '', 2));
      });
    }
    else
      Common.displayHosts();
  });

program
  .command('conf:generate')
  .description('Generate a Gridfile')
  .action(function(opts) {
    Common.generateGridfile(process.cwd())
      .then((data) => {
        console.log(chalk.bold('Gridfile generated in current path (%s)'), data.file);
        console.log();
        console.log(chalk.bold('Gridfile content:\n'));
        var file = fs.readFileSync(data.file);
        console.log(file.toString());
      })
      .catch((err) => {
        exitError(err);
      });
  });

program
  .command('conf:update')
  .description('Update Gridfile with current hosts')
  .action(function(opts) {
    var gridfile = path.join(process.cwd(), 'Gridfile');
    Common.updateGridfile(gridfile)
      .then((data) => {
        console.log(chalk.bold('Gridfile updated (%s)'), data.file);
        console.log();
        console.log(chalk.bold('Gridfile content:\n'));
        var file = fs.readFileSync(data.file);
        console.log(file.toString());
      })
      .catch((err) => {
        exitError(err);
      });
  });

program
  .command('conf:provision')
  .description('Provision each host declared in Gridfile')
  .action(function(gridfile) {
    var conf_path = path.join(process.cwd(), 'Gridfile');

    Common.parseGridfile(conf_path)
      .then((conf) => {
        async.forEachLimit(conf.servers, 5, (server, next) => {
          SSH.copy_install_script(server, conf)
            .then(function() {
              next();
            })
            .catch(e => {
              next();
            })
        }, (err) => {
          var cmd;

          if (conf.grid_password)
            cmd = "cat /tmp/install.sh | GRID=" + conf.grid_name + " GRID_AUTH=" + conf.grid_password + " bash"
          else
            cmd = "cat /tmp/install.sh | GRID=" + conf.grid_name + " bash"

          execCmd({
            cmd         : cmd,
            server_list : conf.servers,
            title       : 'Provisioning Grid'
          });
        });
      })
      .catch((e) => {
        exitError(e);
      });
  });

program
  .command('conf:multissh <gridfile> <bash_command>')
  .description('Execute a bash command on each Grid nodes')
  .action(function(gridfile, bash_command) {
    var conf_path = path.join(process.cwd(), 'Gridfile');

    Common.parseGridfile(conf_path)
      .then((conf) => {
        execCmd({
          cmd         : bash_command,
          server_list : conf.servers
        });
      }).catch(e => {
        exitError(e);
      });
  });

program
  .command('conf:recover')
  .alias('restart')
  .description('Restore the Grid based on current Gridfile')
  .action(function(hostfile, gridname, opts) {
    var conf_path = path.join(process.cwd(), 'Gridfile');

    Common.parseGridfile(conf_path)
      .then((gridfile) => {
        var servers = gridfile.servers;
        var grid_name = gridfile.grid_name;

        console.log(chalk.bold('☢ Launching recovery for %s hosts'), servers.length);
        console.log(chalk.bold('☢ Forcing grid name %s'), grid_name);

        var cmd = 'GRID="' + grid_name + '"';

        if (gridfile.grid_password)
          cmd += ' GRID_AUTH="' + gridfile.grid_password + '"';

        cmd += ' pm2 restart gridcontrol';

        execCmd({
          cmd         : cmd,
          server_list : servers,
          title       : 'Recovering Grid: ' + grid_name
        });
      })

  });

program
  .command('upgrade <gridfile>')
  .description('Upgrade whole grid to latest gridcontrol version')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      grid.listHosts(function(err, hosts) {

        execCmd({
          cmd         : 'GRID=' + hosts[0].ns + ' pm2 install gridcontrol',
          server_list : server_list,
          title       : 'Upgrading Gridcontrol to latest'
        });

      })
    });
  });

/**
 * These following commands uses directly SSH
 */
program
  .command('conf:keycopy [custom_ssh_key]')
  .option('--only <ip>')
  .description('Install public key on remote hosts (default to $HOME/.ssh/id_rsa.pub)')
  .action(function(gridfile, custom_key, opts) {
    var conf_path = path.join(process.cwd(), 'Gridfile');

    Common.parseGridfile(conf_path)
      .then((conf) => {
        if (conf.ssh_key && custom_key) {
          return exitError(new Error('You cannot specify a custom key and having a ssh key into your gridfile'));
        }
        custom_key = conf.ssh_key;
        SSH.copy_public_key(conf, custom_key, opts)
          .then(commands => {
            console.log('Keys copied to %d hosts', commands.length);
            exitSuccess();
          })
          .catch(e => {
            exitError(e);
          })
      });
  });


program
  .command('provision <username> <ip> <grid_name>')
  .option('--ssh_key <public_ssh_key>')
  .option('--grid_password <grid password>')
  .description('provision a remote node')
  .action(function(user, ip, grid_name, opts) {
    SSH.provision_target({
      user: user,
      ip : ip
    }, {
      grid_name : grid_name,
      ssh_key : opts ? opts.key : null
    }).then(function() {
      Common.displayHosts(function() {
        exitSuccess('✓ Remote node successfully provisioned');
      });
    })
      .catch(e => {
        exitError(e);
      })
  });

program
  .command('keygen <key_name>')
  .option('--no-chmod')
  .description('Generate SSH keypairs')
  .action(function(name, opts) {
    console.log(chalk.bold('Generating, it can take some time (~10secs)'));

    SSH.generate_keypair(name)
      .then((keypair) => {
        console.log(chalk.bold('Done.\n'));

        var public_key = name + '.pub';

        fs.writeFileSync(public_key, keypair.public);
        fs.writeFileSync(name, keypair.private);

        if (opts.chmod) {
          fs.chmodSync(public_key, '400');
          fs.chmodSync(name, '400');
        }

        console.log('Generated Public key:');
        console.log(chalk.bold('./' + public_key));
        console.log('Generated Private key:');
        console.log(chalk.bold('./' + name));
        console.log('Copy to target hosts:');
        console.log(chalk.bold('$ grid keycopy [gridfile] ' + public_key));
        exitSuccess();
      })
      .catch(e => {
        exitError(e);
      });
  });

program
  .command('unprovision')
  .description('Uninstall grid control on all nodes')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);

      execCmd({
        cmd : 'pm2 uninstall gridcontrol',
        server_list : server_list,
        title : 'Unprovisioning Gridcontrol'
      });

    });
  });

program
  .command('detect')
  .description('Use nmap to discover machines in network')
  .action(function(opts) {
    var exec = shelljs.exec('sudo nmap -sP 192.168.0.1/24', function() {
      Common.displayHosts();
    });
  });

program
  .command('move <new_grid_name>')
  .description('move all server to another grid namespace')
  .action(function(new_grid_name) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);

      execCmd({
        cmd         : 'GRID="' + new_grid_name + '" pm2 restart gridcontrol',
        server_list : server_list,
        title       : 'Moving current grid to new one'
      });
    });
  });

program
  .command('list-tasks')
  .alias('tasks')
  .description('List all tasks')
  .action(function() {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);

      execCmd({
        cmd         : 'pm2 ls',
        server_list : server_list,
        title       : 'List all tasks'
      });
    });
  });

program
  .command('multissh <bash_command>')
  .description('Execute a bash command on each Grid nodes')
  .action(function(bash_command) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);

      execCmd({
        cmd         : bash_command,
        server_list : server_list
      });
    });
  });

program
  .command('logs [task_name]')
  .alias('log')
  .description('Display logs of all nodes')
  .action(function(task_name) {
    listServerForMulti(function(err, server_list) {
      if (err) return exitError(err);
      var cmd = 'pm2 logs' + (task_name ? ' ' + task_name : '');

      execCmd({
        cmd         : cmd,
        server_list : server_list,
        title       : 'Displaying logs'
      });

    });
  });

/**
 * Generics
 */
program
  .command('*')
  .action(function(env){
    console.log('Enter a Valid command');
    program.outputHelp();
    process.exit(0);
  });

program.parse(process.argv);

if (!process.argv.slice(2).length) {
  program.outputHelp();
}

/**
 * @param {Object}   opts
 * @param {String}   opts.cmd command to execute
 * @param {Object[]} opts.server_list Server list (ip, user, local)
 * @param {String}   [opts.title="MultiSSH] Optional window title
 */
function execCmd(opts) {
  multissh.start(opts, function() {
    Common.displayHosts(function() {
      exitSuccess()
    });
  });
};

function listServerForMulti(cb) {
  grid.listHosts(function(err, hosts) {
    if (err) return cb(err);
    var server_list = [];

    hosts.forEach(function(host) {
      server_list.push({
        ip : host.public_ip,
        user : host.user,
        local : host.local
      });
    });

    return cb(null, server_list);
  });
}

function exitError(err) {
  console.trace(err);
  process.exit(1);
}

function exitSuccess(msg) {
  console.log('');
  console.log(chalk.bold.green(msg || '✓ Action successfully executed'));
  process.exit(0);
}
